# Copyright (c) 2025 Bytedance Ltd. and/or its affiliates

import json
import os
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np

from byteff2.toolkit.openmmtool import AmoebaCalculator


class DimerEnergyScannerFromParams:
    """
    ä» params æ–‡ä»¶å¤¹è¯»å–å·²æœ‰æ–‡ä»¶è¿›è¡ŒäºŒèšä½“èƒ½é‡æ‰«æ
    æ–‡ä»¶ç»“æ„: ./params/{mol_name}/ åŒ…å« .itp, .atp, .gro, _params.json ç­‰æ–‡ä»¶
    """
    
    def __init__(self, params_dir='./params', work_dir='./dimer_scan_results'):
        """
        åˆå§‹åŒ–æ‰«æå™¨
        
        Args:
            params_dir: å‚æ•°æ–‡ä»¶å¤¹æ ¹ç›®å½•
            work_dir: å·¥ä½œç›®å½•ï¼Œä¿å­˜ç»“æœæ–‡ä»¶
        """
        self.params_dir = Path(params_dir)
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(exist_ok=True, parents=True)
        
        if not self.params_dir.exists():
            raise ValueError(f"å‚æ•°ç›®å½•ä¸å­˜åœ¨: {self.params_dir}")
    
    def find_molecule_files(self, mol_name: str):
        """
        æŸ¥æ‰¾åˆ†å­çš„æ‰€æœ‰å¿…éœ€æ–‡ä»¶
        
        Args:
            mol_name: åˆ†å­åç§°
            
        Returns:
            files: åŒ…å«æ‰€æœ‰æ–‡ä»¶è·¯å¾„çš„å­—å…¸
        """
        mol_dir = self.params_dir / mol_name
        
        if not mol_dir.exists():
            raise ValueError(f"åˆ†å­ç›®å½•ä¸å­˜åœ¨: {mol_dir}")
        
        # æŸ¥æ‰¾æ–‡ä»¶
        files = {}
        
        # æŸ¥æ‰¾ .itp æ–‡ä»¶
        itp_files = list(mol_dir.glob(f'{mol_name}.itp'))
        if not itp_files:
            raise ValueError(f"æœªæ‰¾åˆ° {mol_name}.itp æ–‡ä»¶")
        files['itp'] = str(itp_files[0])
        
        # æŸ¥æ‰¾ .atp æ–‡ä»¶ï¼ˆatomtypes å®šä¹‰ï¼‰
        atp_files = list(mol_dir.glob(f'{mol_name}.atp'))
        if atp_files:
            files['atp'] = str(atp_files[0])
        else:
            files['atp'] = None
            print(f"  è­¦å‘Š: æœªæ‰¾åˆ° {mol_name}.atp æ–‡ä»¶")
        
        # æŸ¥æ‰¾ .gro æ–‡ä»¶
        gro_files = list(mol_dir.glob(f'{mol_name}.gro'))
        if not gro_files:
            raise ValueError(f"æœªæ‰¾åˆ° {mol_name}.gro æ–‡ä»¶")
        files['gro'] = str(gro_files[0])
        
        # æŸ¥æ‰¾å‚æ•° JSON æ–‡ä»¶
        params_files = list(mol_dir.glob(f'{mol_name}.json'))
        if not params_files:
            raise ValueError(f"æœªæ‰¾åˆ° {mol_name}.json æ–‡ä»¶")
        files['params'] = str(params_files[0])
        
        # æŸ¥æ‰¾å…ƒæ•°æ®æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
        metadata_files = list(mol_dir.glob(f'{mol_name}_nb_params.json'))
        if metadata_files:
            files['metadata'] = str(metadata_files[0])
        else:
            files['metadata'] = None
        
        print(f"æ‰¾åˆ° {mol_name} çš„æ–‡ä»¶:")
        for key, path in files.items():
            if path:
                print(f"  {key}: {path}")
        
        return files
    
    def create_dimer_topology(self, mol1_name: str, mol2_name: str,
                             files1: dict, files2: dict,
                             top_file: str = None):
        """
        åˆ›å»ºäºŒèšä½“æ‹“æ‰‘æ–‡ä»¶ï¼ˆä½¿ç”¨ #include æ–¹å¼ï¼‰
        
        Args:
            mol1_name: åˆ†å­1çš„åç§°
            mol2_name: åˆ†å­2çš„åç§°
            files1: åˆ†å­1çš„æ–‡ä»¶å­—å…¸
            files2: åˆ†å­2çš„æ–‡ä»¶å­—å…¸
            top_file: è¾“å‡ºçš„ top æ–‡ä»¶è·¯å¾„
            
        Returns:
            top_file: ç”Ÿæˆçš„æ‹“æ‰‘æ–‡ä»¶è·¯å¾„
        """
        if top_file is None:
            top_file = str(self.work_dir / f'{mol1_name}_{mol2_name}_dimer.top')
        
        with open(top_file, 'w') as f:
            f.write("; GROMACS topology file for dimer system\n")
            f.write("; Generated by DimerEnergyScannerFromParams\n")
            f.write(f"; Molecules: {mol1_name} + {mol2_name}\n\n")
            
            # Defaults section
            f.write("[ defaults ]\n")
            f.write("; nbfunc        comb-rule       gen-pairs       fudgeLJ     fudgeQQ\n")
            f.write("1               3               yes             0.5         0.5\n\n")
            
            # Atomtypes section
            f.write("[ atomtypes ]\n")
            f.write("; include atp/itp files here\n\n")
            
            # Include .atp files (atomtypes definitions)
            for mol_name, file_dict in [(mol1_name, files1), (mol2_name, files2)]:
                if file_dict['atp']:
                    atp_path = Path(file_dict['atp']).absolute()
                    f.write(f'#include "{atp_path}"\n')
            
            f.write("\n")
            
            # Include .itp files (molecule definitions)
            for mol_name, file_dict in [(mol1_name, files1), (mol2_name, files2)]:
                itp_path = Path(file_dict['itp']).absolute()
                f.write(f'#include "{itp_path}"\n')
            
            f.write("\n")
            
            # System section
            f.write("[ system ]\n")
            f.write("; Name\n")
            f.write(f"{mol1_name} {mol2_name} dimer\n\n")
            
            # Molecules section
            f.write("[ molecules ]\n")
            f.write("; Compound        #mols\n")
            f.write(f"{mol1_name}  1\n")
            f.write(f"{mol2_name}  1\n")
        
        print(f"âœ“ äºŒèšä½“æ‹“æ‰‘æ–‡ä»¶å·²åˆ›å»º: {top_file}")
        
        return top_file
    
    def load_params_from_files(self, mol1_name: str, mol2_name: str,
                              mol1_params_json: str, mol2_params_json: str,
                              metadata_json: str = None):
        """
        ä» JSON æ–‡ä»¶åŠ è½½åŠ›åœºå‚æ•°
        
        Args:
            mol1_name: åˆ†å­1çš„åç§°
            mol2_name: åˆ†å­2çš„åç§°
            mol1_params_json: åˆ†å­1çš„å‚æ•°æ–‡ä»¶è·¯å¾„
            mol2_params_json: åˆ†å­2çš„å‚æ•°æ–‡ä»¶è·¯å¾„
            metadata_json: å…ƒæ•°æ®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            nonbonded_params: å®Œæ•´çš„éé”®å‚æ•°å­—å…¸
        """
        # åŠ è½½åˆ†å­1çš„å‚æ•°
        with open(mol1_params_json, 'r') as f:
            params1 = json.load(f)
        
        # åŠ è½½åˆ†å­2çš„å‚æ•°
        with open(mol2_params_json, 'r') as f:
            params2 = json.load(f)
        
        # åŠ è½½æˆ–åˆ›å»º metadata
        if metadata_json and os.path.exists(metadata_json):
            with open(metadata_json, 'r') as f:
                metadata_dict = json.load(f)
                metadata = metadata_dict.get('metadata', metadata_dict)
        else:
            # ä½¿ç”¨é»˜è®¤ metadata
            metadata = {
                's12': 0.15,
                'disp_damping': 0.4
            }
            print("  ä½¿ç”¨é»˜è®¤ metadata å‚æ•°")
        
        # æ„å»ºå®Œæ•´çš„éé”®å‚æ•°å­—å…¸
        nonbonded_params = {
            'metadata': metadata,
            mol1_name: params1,
            mol2_name: params2
        }
        
        # ä¿å­˜å®Œæ•´å‚æ•°ä¾›å‚è€ƒ
        full_params_file = self.work_dir / f'{mol1_name}_{mol2_name}_nonbonded_params.json'
        with open(full_params_file, 'w') as f:
            json.dump(nonbonded_params, f, indent=2)
        print(f"âœ“ å®Œæ•´éé”®å‚æ•°å·²ä¿å­˜åˆ°: {full_params_file}")
        
        return nonbonded_params
    
    def load_geometries(self, mol1_gro: str, mol2_gro: str):
        """
        ä» gro æ–‡ä»¶åŠ è½½åˆ†å­å‡ ä½•ç»“æ„
        
        Args:
            mol1_gro: åˆ†å­1çš„ gro æ–‡ä»¶è·¯å¾„
            mol2_gro: åˆ†å­2çš„ gro æ–‡ä»¶è·¯å¾„
            
        Returns:
            coords1, coords2: ä¸¤ä¸ªåˆ†å­çš„åæ ‡ (numpy arrays)
        """
        import ase.io as aio
        
        atoms1 = aio.read(mol1_gro)
        atoms2 = aio.read(mol2_gro)
        
        coords1 = atoms1.get_positions()  # Ã…
        coords2 = atoms2.get_positions()  # Ã…
        
        return coords1, coords2
    
    def load_dimer_structures_from_dir(self, structure_dir: str, mol1_name: str, mol2_name: str):
        """
        ä»ç›®å½•åŠ è½½äºŒèšä½“ç»“æ„ï¼ˆæ¯ä¸ª xyz æ–‡ä»¶åŒ…å«å¤šä¸ªæ„è±¡ï¼‰
        æ–‡ä»¶æ ¼å¼: {dirname}/{name}_0.xyz å’Œ {dirname}/{name}_1.xyz
        æ¯ä¸ª xyz æ–‡ä»¶åŒ…å«å¤šå¸§ç»“æ„
        
        Args:
            structure_dir: åŒ…å«å­ç›®å½•çš„æ ¹ç›®å½•
            mol1_name: åˆ†å­1çš„åç§°
            mol2_name: åˆ†å­2çš„åç§°
            
        Returns:
            coords_list: åæ ‡åˆ—è¡¨
            distances: è·ç¦»åˆ—è¡¨
            dir_names: ç›®å½•ååˆ—è¡¨
        """
        from bytemol.core import Molecule
        
        structure_dir = Path(structure_dir)
        if not structure_dir.exists():
            raise ValueError(f"ç»“æ„ç›®å½•ä¸å­˜åœ¨: {structure_dir}")
        
        # è·å–æ‰€æœ‰å­ç›®å½•
        subdirs = [d for d in structure_dir.iterdir() if d.is_dir()]
        
        if not subdirs:
            raise ValueError(f"åœ¨ {structure_dir} ä¸­æœªæ‰¾åˆ°å­ç›®å½•")
        
        print(f"æ‰¾åˆ° {len(subdirs)} ä¸ªå­ç›®å½•")
        
        coords_list = []
        distances = []
        dir_names = []
        conformer_ids = []  # è®°å½•æ¯ä¸ªæ„è±¡æ‰€å±çš„ç›®å½•å’Œå¸§å·
        
        for subdir in sorted(subdirs):
            dirname = subdir.name
            
            # æŸ¥æ‰¾ xyz æ–‡ä»¶: {name}_0.xyz å’Œ {name}_1.xyz
            xyz_files = []
            for i, name in enumerate([mol1_name, mol2_name]):
                xyz_file = subdir / f'{name}_{i}.xyz'
                if not xyz_file.exists():
                    print(f"  è­¦å‘Š: æœªæ‰¾åˆ° {xyz_file}ï¼Œè·³è¿‡ {dirname}")
                    break
                xyz_files.append(str(xyz_file))
            
            if len(xyz_files) != 2:
                continue
            
            try:
                # ä½¿ç”¨ bytemol.Molecule åŠ è½½ï¼ˆæ”¯æŒå¤šæ„è±¡ï¼‰
                mols = [Molecule(xyz_file) for xyz_file in xyz_files]
                
                # è·å–æ„è±¡æ•°
                nconfs1 = mols[0].nconfs
                nconfs2 = mols[1].nconfs
                
                if nconfs1 != nconfs2:
                    print(f"  è­¦å‘Š: {dirname} ä¸­ä¸¤ä¸ªåˆ†å­çš„æ„è±¡æ•°ä¸åŒ¹é… ({nconfs1} vs {nconfs2})ï¼Œè·³è¿‡")
                    continue
                
                print(f"  å¤„ç† {dirname}: {nconfs1} ä¸ªæ„è±¡")
                
                # éå†æ¯ä¸ªæ„è±¡
                for conf_idx in range(nconfs1):
                    # è·å–åæ ‡ (é€šè¿‡ get_confdata è·å–æ‰€æœ‰æ„è±¡çš„åæ ‡)
                    coords_raw = [np.array(mol.get_confdata('coords')) for mol in mols]
                    
                    # coords_raw çš„å½¢çŠ¶æ˜¯ (nconfs, natoms, 3)
                    # æå–ç¬¬ conf_idx ä¸ªæ„è±¡
                    coords1 = coords_raw[0][conf_idx]
                    coords2 = coords_raw[1][conf_idx]
                    
                    # åˆå¹¶åæ ‡
                    coords = np.vstack([coords1, coords2])
                    coords_list.append(coords)
                    
                    # è®¡ç®—è´¨å¿ƒè·ç¦»
                    center1 = coords1.mean(axis=0)
                    center2 = coords2.mean(axis=0)
                    distance = np.linalg.norm(center2 - center1)
                    distances.append(distance)
                    
                    # è®°å½•ä¿¡æ¯
                    dir_names.append(dirname)
                    conformer_ids.append((dirname, conf_idx))
                    
                    if conf_idx < 3 or conf_idx == nconfs1 - 1:  # åªæ‰“å°å‰3ä¸ªå’Œæœ€åä¸€ä¸ª
                        print(f"    æ„è±¡ {conf_idx:3d}: d = {distance:.3f} Ã…")
                    elif conf_idx == 3:
                        print(f"    ...")
                
            except Exception as e:
                print(f"  âœ— åŠ è½½ {dirname} æ—¶å‡ºé”™: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        if not coords_list:
            raise ValueError("æœªèƒ½åŠ è½½ä»»ä½•æœ‰æ•ˆçš„ç»“æ„")
        
        print(f"\nâœ“ æ€»å…±åŠ è½½ {len(coords_list)} ä¸ªäºŒèšä½“æ„è±¡")
        
        # æŒ‰è·ç¦»æ’åº
        sorted_indices = np.argsort(distances)
        coords_list = [coords_list[i] for i in sorted_indices]
        distances = [distances[i] for i in sorted_indices]
        dir_names = [dir_names[i] for i in sorted_indices]
        conformer_ids = [conformer_ids[i] for i in sorted_indices]
        
        return coords_list, distances, dir_names, conformer_ids
    
    def generate_scan_geometries(self, coords1, coords2, 
                                  distances, scan_direction='x'):
        """
        ç”Ÿæˆä¸åŒè·ç¦»çš„äºŒèšä½“å‡ ä½•æ„å‹
        
        Args:
            coords1, coords2: ä¸¤ä¸ªåˆ†å­çš„åæ ‡
            distances: æ‰«æè·ç¦»æ•°ç»„ (Ã…)
            scan_direction: æ‰«ææ–¹å‘ ('x', 'y', 'z')
            
        Returns:
            coords_list: æ¯ä¸ªè·ç¦»å¯¹åº”çš„åæ ‡æ•°ç»„åˆ—è¡¨
        """
        coords1 = coords1.copy()
        coords2 = coords2.copy()
        
        # ä¸­å¿ƒåŒ–åˆ†å­
        center1 = coords1.mean(axis=0)
        center2 = coords2.mean(axis=0)
        coords1 -= center1
        coords2 -= center2
        
        # è®¾ç½®æ‰«ææ–¹å‘å‘é‡
        direction_map = {'x': [1, 0, 0], 'y': [0, 1, 0], 'z': [0, 0, 1]}
        direction = np.array(direction_map[scan_direction])
        
        coords_list = []
        for d in distances:
            # mol1 æ”¾åœ¨åŸç‚¹ï¼Œmol2 æ²¿æ‰«ææ–¹å‘ç§»åŠ¨
            coords2_shifted = coords2 + direction * d
            combined_coords = np.vstack([coords1, coords2_shifted])
            coords_list.append(combined_coords)
        
        return coords_list
    
    def calculate_from_structure_dir(self,
                                     mol1_name: str,
                                     mol2_name: str,
                                     structure_dir: str,
                                     platform='CPU',
                                     compare_qm: bool = False):
        """
        ä»ç»“æ„ç›®å½•è®¡ç®—èƒ½é‡ï¼ˆæ”¯æŒå¤šæ„è±¡ xyz æ–‡ä»¶ï¼‰
        
        Args:
            mol1_name: åˆ†å­1çš„åç§°
            mol2_name: åˆ†å­2çš„åç§°
            structure_dir: åŒ…å«å­ç›®å½•çš„æ ¹ç›®å½•ï¼Œæ¯ä¸ªå­ç›®å½•åŒ…å« {name}_0.xyz å’Œ {name}_1.xyz
            platform: OpenMM å¹³å°
            compare_qm: æ˜¯å¦å°è¯•åŠ è½½ QM å‚è€ƒæ•°æ®ï¼ˆEDA.jsonï¼‰
            
        Returns:
            results: åŒ…å«è·ç¦»ã€èƒ½é‡å’Œèƒ½é‡åˆ†è§£çš„å­—å…¸
        """
        # 1. æŸ¥æ‰¾å‚æ•°æ–‡ä»¶
        print("\n" + "="*60)
        print("æ­¥éª¤ 1: æŸ¥æ‰¾åˆ†å­æ–‡ä»¶")
        print("="*60)
        files1 = self.find_molecule_files(mol1_name)
        print()
        files2 = self.find_molecule_files(mol2_name)
        
        # 2. åŠ è½½ç»“æ„ï¼ˆæ”¯æŒå¤šæ„è±¡ï¼‰
        print("\n" + "="*60)
        print("æ­¥éª¤ 2: åŠ è½½äºŒèšä½“ç»“æ„ï¼ˆå¤šæ„è±¡ï¼‰")
        print("="*60)
        coords_list, distances, dir_names, conformer_ids = self.load_dimer_structures_from_dir(
            structure_dir, mol1_name, mol2_name
        )
        
        # 3. åˆ›å»ºäºŒèšä½“æ‹“æ‰‘æ–‡ä»¶
        print("\n" + "="*60)
        print("æ­¥éª¤ 3: åˆ›å»ºäºŒèšä½“æ‹“æ‰‘")
        print("="*60)
        top_file = self.create_dimer_topology(
            mol1_name, mol2_name, files1, files2
        )
        
        # 4. åŠ è½½åŠ›åœºå‚æ•°
        print("\n" + "="*60)
        print("æ­¥éª¤ 4: åŠ è½½åŠ›åœºå‚æ•°")
        print("="*60)
        
        metadata_json = files1['metadata'] or files2['metadata']
        
        nonbonded_params = self.load_params_from_files(
            mol1_name, mol2_name,
            files1['params'], files2['params'],
            metadata_json
        )
        
        # 5. åˆ›å»º OpenMM Calculator
        print("\n" + "="*60)
        print("æ­¥éª¤ 5: åˆ›å»º OpenMM Calculator")
        print("="*60)
        
        try:
            calculator = AmoebaCalculator(
                top_file=top_file,
                nonbonded_params=nonbonded_params,
                platform_name=platform,
                separate_terms=True,
                unit_cell=None            )
            print(f"âœ“ Calculator åˆ›å»ºå®Œæˆ (å¹³å°: {platform})")
        except Exception as e:
            print(f"âœ— åˆ›å»º Calculator æ—¶å‡ºé”™: {e}")
            raise
        
        # 6. åŠ è½½ QM æ•°æ®ï¼ˆå¦‚æœéœ€è¦ï¼‰
        qm_data_dict = {}
        if compare_qm:
            print("\n" + "="*60)
            print("æ­¥éª¤ 6: åŠ è½½ QM å‚è€ƒæ•°æ®")
            print("="*60)
            
            for dirname in set(dir_names):
                qm_file = Path(structure_dir) / dirname / 'EDA.json'
                if qm_file.exists():
                    try:
                        with open(qm_file, 'r') as f:
                            qm_data_dict[dirname] = json.load(f)
                        print(f"  âœ“ åŠ è½½ {dirname}/EDA.json")
                    except Exception as e:
                        print(f"  âœ— åŠ è½½ {qm_file} æ—¶å‡ºé”™: {e}")
        
        # 7. è®¡ç®—èƒ½é‡
        print("\n" + "="*60)
        print("æ­¥éª¤ 7: è®¡ç®—èƒ½é‡")
        print("="*60)
        
        results = {
            'mol1_name': mol1_name,
            'mol2_name': mol2_name,
            'source': 'structure_dir',
            'structure_dir': str(structure_dir),
            'dir_names': dir_names,
            'conformer_ids': [(d, int(i)) for d, i in conformer_ids],
            'distances': [float(d) for d in distances],
            'total_energy': [],
            'energy_components': {},
        }
        
        # å¦‚æœéœ€è¦æ¯”è¾ƒ QM æ•°æ®
        if compare_qm and qm_data_dict:
            results['qm_data'] = {}
        
        for i, (d, coords, dirname, conf_id) in enumerate(zip(distances, coords_list, dir_names, conformer_ids)):
            print(f"  [{i+1:3d}/{len(coords_list)}] {dirname:25s} æ„è±¡ {conf_id[1]:3d}  d = {d:.2f} Ã…", 
                  end='', flush=True)
            
            # è®¡ç®—æ€»èƒ½é‡å’ŒåŠ›
            energy, forces = calculator._calculate_without_restraint(coords)
            results['total_energy'].append(energy)
            
            # è·å–èƒ½é‡åˆ†è§£
            separate_energy, separate_forces = calculator.get_separate_terms()
            
            for term, e in separate_energy.items():
                if term not in results['energy_components']:
                    results['energy_components'][term] = []
                results['energy_components'][term].append(e)
            
            print(f"  â†’  E = {energy:10.4f} kcal/mol")
            
            # æ·»åŠ  QM æ•°æ®
            if compare_qm and dirname in qm_data_dict:
                qm_data = qm_data_dict[dirname]
                
                if i == 0:
                    # åˆå§‹åŒ– QM æ•°æ®é”®
                    for key in qm_data:
                        results['qm_data'][key] = []
                
                # æ·»åŠ  QM æ•°æ®ï¼ˆå¯¹åº”å½“å‰æ„è±¡ï¼‰
                for key in results['qm_data']:
                    if key in qm_data:
                        val = qm_data[key]
                        # å¦‚æœæ˜¯åˆ—è¡¨ï¼Œå–å¯¹åº”æ„è±¡çš„å€¼
                        if isinstance(val, list):
                            results['qm_data'][key].append(val[conf_id[1]] if conf_id[1] < len(val) else None)
                        else:
                            results['qm_data'][key].append(val)
                    else:
                        results['qm_data'][key].append(None)
        
        # 8. ä¿å­˜ç»“æœ
        results_file = self.work_dir / f'{mol1_name}_{mol2_name}_results.json'
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nâœ“ ç»“æœå·²ä¿å­˜åˆ°: {results_file}")
        
        return results
    
    def calculate_dimer_scan(self, 
                            mol1_name: str, 
                            mol2_name: str,
                            distances=None,
                            scan_direction='x',
                            platform='CPU'):
        """
        æ‰§è¡Œå®Œæ•´çš„äºŒèšä½“èƒ½é‡æ‰«æï¼ˆè‡ªåŠ¨æŸ¥æ‰¾æ–‡ä»¶ï¼‰
        
        Args:
            mol1_name: åˆ†å­1çš„åç§°ï¼ˆå¯¹åº” params ä¸‹çš„æ–‡ä»¶å¤¹åï¼‰
            mol2_name: åˆ†å­2çš„åç§°ï¼ˆå¯¹åº” params ä¸‹çš„æ–‡ä»¶å¤¹åï¼‰
            distances: æ‰«æè·ç¦»æ•°ç»„ (Ã…)
            scan_direction: æ‰«ææ–¹å‘
            platform: OpenMM å¹³å° ('CPU' æˆ– 'CUDA')
            
        Returns:
            results: åŒ…å«è·ç¦»ã€èƒ½é‡å’Œèƒ½é‡åˆ†è§£çš„å­—å…¸
        """
        if distances is None:
            distances = np.linspace(2.5, 8.0, 20)
        
        # 1. æŸ¥æ‰¾æ–‡ä»¶
        print("\n" + "="*60)
        print("æ­¥éª¤ 1: æŸ¥æ‰¾åˆ†å­æ–‡ä»¶")
        print("="*60)
        files1 = self.find_molecule_files(mol1_name)
        print()
        files2 = self.find_molecule_files(mol2_name)
        
        # 2. åˆ›å»ºäºŒèšä½“æ‹“æ‰‘æ–‡ä»¶
        print("\n" + "="*60)
        print("æ­¥éª¤ 2: åˆ›å»ºäºŒèšä½“æ‹“æ‰‘")
        print("="*60)
        top_file = self.create_dimer_topology(
            mol1_name, mol2_name, files1, files2
        )
        
        # 3. åŠ è½½åŠ›åœºå‚æ•°
        print("\n" + "="*60)
        print("æ­¥éª¤ 3: åŠ è½½åŠ›åœºå‚æ•°")
        print("="*60)
        
        # ä¼˜å…ˆä½¿ç”¨ mol1 çš„ metadataï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ mol2 çš„
        metadata_json = files1['metadata'] or files2['metadata']
        
        nonbonded_params = self.load_params_from_files(
            mol1_name, mol2_name,
            files1['params'], files2['params'],
            metadata_json
        )
        
        # 4. åŠ è½½åˆ†å­å‡ ä½•ç»“æ„
        print("\n" + "="*60)
        print("æ­¥éª¤ 4: åŠ è½½åˆ†å­å‡ ä½•ç»“æ„")
        print("="*60)
        coords1, coords2 = self.load_geometries(files1['gro'], files2['gro'])
        print(f"  {mol1_name} åŸå­æ•°: {len(coords1)}")
        print(f"  {mol2_name} åŸå­æ•°: {len(coords2)}")
        
        # 5. åˆ›å»º OpenMM Calculator
        print("\n" + "="*60)
        print("æ­¥éª¤ 5: åˆ›å»º OpenMM Calculator")
        print("="*60)
        
        try:
            calculator = AmoebaCalculator(
                top_file=top_file,
                nonbonded_params=nonbonded_params,
                platform_name=platform,
                separate_terms=True  # å¼€å¯èƒ½é‡åˆ†è§£
            )
            print(f"âœ“ Calculator åˆ›å»ºå®Œæˆ (å¹³å°: {platform})")
        except Exception as e:
            print(f"âœ— åˆ›å»º Calculator æ—¶å‡ºé”™: {e}")
            print("\nè°ƒè¯•ä¿¡æ¯ - æ‹“æ‰‘æ–‡ä»¶å†…å®¹:")
            with open(top_file, 'r') as f:
                for i, line in enumerate(f, 1):
                    print(f"{i:3d}: {line.rstrip()}")
            raise
        
        # 6. ç”Ÿæˆæ‰«æå‡ ä½•æ„å‹
        print("\n" + "="*60)
        print("æ­¥éª¤ 6: ç”Ÿæˆæ‰«ææ„å‹")
        print("="*60)
        coords_list = self.generate_scan_geometries(
            coords1, coords2, distances, scan_direction
        )
        print(f"  ç”Ÿæˆ {len(distances)} ä¸ªæ„å‹")
        print(f"  è·ç¦»èŒƒå›´: {distances[0]:.2f} - {distances[-1]:.2f} Ã…")
        print(f"  æ‰«ææ–¹å‘: {scan_direction}")
        
        # 7. è®¡ç®—èƒ½é‡
        print("\n" + "="*60)
        print("æ­¥éª¤ 7: è®¡ç®—èƒ½é‡")
        print("="*60)
        
        results = {
            'mol1_name': mol1_name,
            'mol2_name': mol2_name,
            'scan_direction': scan_direction,
            'source': 'scan',
            'distances': distances.tolist(),
            'total_energy': [],
            'energy_components': {},
        }
        
        for i, (d, coords) in enumerate(zip(distances, coords_list)):
            print(f"  [{i+1:2d}/{len(distances)}] d = {d:.2f} Ã…", end='', flush=True)
            
            # è®¡ç®—æ€»èƒ½é‡å’ŒåŠ›
            energy, forces = calculator._calculate_without_restraint(coords)
            results['total_energy'].append(energy)
            
            # è·å–èƒ½é‡åˆ†è§£
            separate_energy, separate_forces = calculator.get_separate_terms()
            
            for term, e in separate_energy.items():
                if term not in results['energy_components']:
                    results['energy_components'][term] = []
                results['energy_components'][term].append(e)
            
            print(f"  â†’  E = {energy:10.4f} kcal/mol")
        
        # 8. ä¿å­˜ç»“æœ
        results_file = self.work_dir / f'{mol1_name}_{mol2_name}_scan_results.json'
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nâœ“ ç»“æœå·²ä¿å­˜åˆ°: {results_file}")
        
        return results
    
    def plot_energy_decomposition(self, results, save_path=None, 
                                  components_to_plot=None,
                                  plot_qm=False,
                                  figsize=(14, 9)):
        """
        ç»˜åˆ¶èƒ½é‡åˆ†è§£å›¾
        
        Args:
            results: ç»“æœå­—å…¸
            save_path: ä¿å­˜è·¯å¾„
            components_to_plot: è¦ç»˜åˆ¶çš„åˆ†é‡
            plot_qm: æ˜¯å¦ç»˜åˆ¶ QM å‚è€ƒæ•°æ®
            figsize: å›¾ç‰‡å¤§å°
        """
        distances = np.array(results['distances'])
        total_energy = np.array(results['total_energy'])
        print(total_energy)
        components = results['energy_components']
        total_energy = np.array(results['energy_components']['AmoebaMultipoleForce'])+ np.array(results['energy_components']['CustomNonbondedForce'])
        print(total_energy)
        # å¦‚æœæœªæŒ‡å®šï¼Œé»˜è®¤ç»˜åˆ¶ä¸»è¦åˆ†é‡
        if components_to_plot is None:
            component_priority = [
                'AmoebaMultipoleForce',
                'CustomNonbondedForce', 
                # 'CustomBondForce',
                # 'HarmonicBondForce',
                # 'HarmonicAngleForce',
                # 'PeriodicTorsionForce'
            ]
            components_to_plot = [c for c in component_priority if c in components]
            
            if not components_to_plot:
                components_to_plot = list(components.keys())
        
        # åˆ›å»ºå›¾å½¢
        fig = plt.figure(figsize=figsize)
        gs = fig.add_gridspec(2, 2, height_ratios=[2, 1], width_ratios=[3, 1])
        
        ax1 = fig.add_subplot(gs[0, :])  # ä¸Šé¢æ•´è¡Œ
        ax2 = fig.add_subplot(gs[1, 0])  # å·¦ä¸‹
        ax3 = fig.add_subplot(gs[1, 1])  # å³ä¸‹
        
        # å®šä¹‰é¢œè‰²æ–¹æ¡ˆ
        colors = plt.cm.tab10(np.linspace(0, 1, len(components_to_plot) + 1))
        
        mol1_name = results.get('mol1_name', 'MOL1')
        mol2_name = results.get('mol2_name', 'MOL2')
        source = results.get('source', 'unknown')
        
        # ä¸Šå›¾: æ€»èƒ½é‡å’Œå„åˆ†é‡
        ax1.plot(distances, total_energy, 'k-', linewidth=3, 
                label='FF Total', marker='o', markersize=6, zorder=10)
        
        # å¦‚æœæœ‰ QM æ•°æ®ï¼Œç»˜åˆ¶å‚è€ƒçº¿
        if plot_qm and 'qm_data' in results and 'TOTAL' in results['qm_data']:
            qm_total = np.array(results['qm_data']['TOTAL'])
            # è¿‡æ»¤æ‰ None å€¼
            valid_mask = np.array([v is not None for v in qm_total])
            if valid_mask.any():
                qm_total_valid = np.array([v if v is not None else np.nan for v in qm_total])
                ax1.plot(distances, qm_total_valid, 'r--', linewidth=2.5, 
                        label='QM Total', marker='^', markersize=5, alpha=0.8)
        
        for i, component in enumerate(components_to_plot):
            if component in components:
                energy = np.array(components[component])
                label = component.replace('Force', '').replace('Amoeba', '').replace('Custom', '')
                ax1.plot(distances, energy, '-', linewidth=2.5, 
                        label=label, color=colors[i], 
                        marker='s', markersize=4, alpha=0.85)
        
        ax1.set_xlabel('Distance (Ã…)', fontsize=13, fontweight='bold')
        ax1.set_ylabel('Energy (kcal/mol)', fontsize=13, fontweight='bold')
        
        title = f'{mol1_name}Â·Â·Â·{mol2_name} Dimer Interaction Energy'
        if source == 'structure_dir':
            title += f' ({len(distances)} conformers)'
        ax1.set_title(title, fontsize=15, fontweight='bold', pad=15)
        
        ax1.legend(loc='best', fontsize=10, framealpha=0.95, ncol=3)
        ax1.grid(True, alpha=0.3, linestyle='--')
        ax1.axhline(y=0, color='gray', linestyle='--', linewidth=1.5, alpha=0.6)
        
        # å·¦ä¸‹å›¾: å †å å›¾
        component_arrays = []
        labels = []
        for component in components_to_plot:
            if component in components:
                component_arrays.append(np.array(components[component]))
                label = component.replace('Force', '').replace('Amoeba', '').replace('Custom', '')
                labels.append(label)
        
        if component_arrays:
            ax2.stackplot(distances, *component_arrays, 
                         labels=labels, alpha=0.75, colors=colors[:len(labels)])
            ax2.set_xlabel('Distance (Ã…)', fontsize=11, fontweight='bold')
            ax2.set_ylabel('Energy (kcal/mol)', fontsize=11, fontweight='bold')
            ax2.set_title('Stacked Components', fontsize=12, fontweight='bold')
            ax2.legend(loc='upper right', fontsize=8, framealpha=0.9)
            ax2.grid(True, alpha=0.3, linestyle='--')
        
        # å³ä¸‹å›¾: èƒ½é‡åˆ†é‡å æ¯”ï¼ˆé¥¼å›¾ï¼‰
        avg_contributions = {}
        for component in components_to_plot:
            if component in components:
                energy = np.abs(np.array(components[component]))
                avg_contributions[component] = np.mean(energy)
        
        if avg_contributions:
            labels_pie = [c.replace('Force', '').replace('Amoeba', '').replace('Custom', '') 
                         for c in avg_contributions.keys()]
            sizes = list(avg_contributions.values())
            
            ax3.pie(sizes, labels=labels_pie, autopct='%1.1f%%',
                   colors=colors[:len(labels_pie)], startangle=90)
            ax3.set_title('Average Contribution', fontsize=12, fontweight='bold')
        
        plt.tight_layout()
        
        # ä¿å­˜å›¾ç‰‡
        if save_path is None:
            suffix = '_structures' if source == 'structure_dir' else ''
            save_path = self.work_dir / f'{mol1_name}_{mol2_name}_energy_decomposition{suffix}.png'
        
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"âœ“ èƒ½é‡åˆ†è§£å›¾å·²ä¿å­˜åˆ°: {save_path}")
        
        # åŒæ—¶ä¿å­˜ PDF ç‰ˆæœ¬
        pdf_path = Path(save_path).with_suffix('.pdf')
        plt.savefig(pdf_path, bbox_inches='tight')
        print(f"âœ“ PDF ç‰ˆæœ¬å·²ä¿å­˜åˆ°: {pdf_path}")
        
        plt.show()
        
        return fig, (ax1, ax2, ax3)
    
    def analyze_interaction_energy(self, results):
        """
        åˆ†æç›¸äº’ä½œç”¨èƒ½
        """
        distances = np.array(results['distances'])
        energies = np.array(results['total_energy'])
        
        # æ‰¾åˆ°èƒ½é‡æœ€å°å€¼
        min_idx = np.argmin(energies)
        min_distance = distances[min_idx]
        min_energy = energies[min_idx]
        
        # ä¼°ç®—å¹³è¡¡è·ç¦»ï¼ˆèƒ½é‡ä¸ºé›¶çš„ç‚¹ï¼‰
        zero_crossings = []
        for i in range(len(energies) - 1):
            if energies[i] * energies[i+1] < 0:
                d0 = distances[i] + (distances[i+1] - distances[i]) * \
                     (-energies[i]) / (energies[i+1] - energies[i])
                zero_crossings.append(d0)
        
        # æ‰¾æœ€å¤§å€¼ï¼ˆæ’æ–¥æœ€å¼ºç‚¹ï¼‰
        max_idx = np.argmax(energies)
        max_distance = distances[max_idx]
        max_energy = energies[max_idx]
        
        analysis = {
            'equilibrium_distance': float(min_distance),
            'minimum_energy': float(min_energy),
            'maximum_distance': float(max_distance),
            'maximum_energy': float(max_energy),
            'zero_crossing_distances': [float(d) for d in zero_crossings],
            'attractive_range': (float(distances[energies < 0].min()) if any(energies < 0) else None,
                               float(distances[energies < 0].max()) if any(energies < 0) else None),
            'energy_range': (float(energies.min()), float(energies.max()))
        }
        
        mol1 = results.get('mol1_name', 'MOL1')
        mol2 = results.get('mol2_name', 'MOL2')
        
        print("\n" + "="*60)
        print(f"{mol1}Â·Â·Â·{mol2} ç›¸äº’ä½œç”¨èƒ½åˆ†æ")
        print("="*60)
        print(f"èƒ½é‡æœ€å°å€¼:     {min_energy:10.4f} kcal/mol  @  {min_distance:.3f} Ã…")
        print(f"èƒ½é‡æœ€å¤§å€¼:     {max_energy:10.4f} kcal/mol  @  {max_distance:.3f} Ã…")
        print(f"èƒ½é‡èŒƒå›´:       {analysis['energy_range'][0]:10.4f} ~ {analysis['energy_range'][1]:10.4f} kcal/mol")
        
        if zero_crossings:
            print(f"èƒ½é‡é›¶ç‚¹:       {', '.join([f'{d:.3f}' for d in zero_crossings])} Ã…")
        
        if analysis['attractive_range'][0] is not None:
            print(f"å¸å¼•åŠ›åŒºåŸŸ:     {analysis['attractive_range'][0]:.3f} - {analysis['attractive_range'][1]:.3f} Ã…")
        
        # ä¿å­˜åˆ†æç»“æœ
        source = results.get('source', 'scan')
        suffix = '_structures' if source == 'structure_dir' else ''
        analysis_file = self.work_dir / f"{mol1}_{mol2}_analysis{suffix}.json"
        with open(analysis_file, 'w') as f:
            json.dump(analysis, f, indent=2)
        print(f"\nâœ“ åˆ†æç»“æœå·²ä¿å­˜åˆ°: {analysis_file}")
        
        return analysis


def main():
    """
    ä¸»å‡½æ•°ï¼šLi-EC ç¤ºä¾‹
    """
    import argparse
    
    parser = argparse.ArgumentParser(
        description='ä» params æ–‡ä»¶å¤¹è¿›è¡ŒäºŒèšä½“èƒ½é‡è®¡ç®—',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  # Li-EC äºŒèšä½“æ‰«æï¼ˆè‡ªåŠ¨ç”Ÿæˆæ„å‹ï¼‰
  python dimer_scan_from_params_folder_final.py --mol1 LI --mol2 EC
  
  # ä»ç»“æ„ç›®å½•è®¡ç®—ï¼ˆæ¯ä¸ªå­ç›®å½•åŒ…å«å¤šæ„è±¡ {name}_0.xyz å’Œ {name}_1.xyzï¼‰
  python dimer_scan_from_params_folder_final.py --mol1 LI --mol2 EC --structure_dir ./dimer_structures
  
  # ä»ç»“æ„ç›®å½•è®¡ç®—å¹¶æ¯”è¾ƒ QM æ•°æ®ï¼ˆéœ€è¦ EDA.json æ–‡ä»¶ï¼‰
  python dimer_scan_from_params_folder_final.py --mol1 LI --mol2 EC --structure_dir ./dimer_structures --compare_qm
  
  # è‡ªå®šä¹‰è·ç¦»èŒƒå›´
  python dimer_scan_from_params_folder_final.py --mol1 LI --mol2 EC --dmin 1.5 --dmax 6.0 --npoints 30
  
  # ä½¿ç”¨ GPU
  python dimer_scan_from_params_folder_final.py --mol1 LI --mol2 EC --platform CUDA
        """
    )
    
    parser.add_argument('--mol1', type=str, default='LI',
                       help='åˆ†å­1çš„åç§°ï¼ˆparams æ–‡ä»¶å¤¹ä¸‹çš„å­ç›®å½•ï¼‰')
    parser.add_argument('--mol2', type=str, default='EC',
                       help='åˆ†å­2çš„åç§°ï¼ˆparams æ–‡ä»¶å¤¹ä¸‹çš„å­ç›®å½•ï¼‰')
    parser.add_argument('--params_dir', type=str, default='./params',
                       help='å‚æ•°æ–‡ä»¶å¤¹æ ¹ç›®å½•')
    parser.add_argument('--structure_dir', type=str, default=None,
                       help='ç»“æ„ç›®å½•ï¼ˆæ¯ä¸ªå­ç›®å½•åŒ…å«å¤šæ„è±¡ {name}_0.xyz å’Œ {name}_1.xyzï¼‰')
    parser.add_argument('--compare_qm', action='store_true',
                       help='æ¯”è¾ƒ QM æ•°æ®ï¼ˆéœ€è¦ç»“æ„ç›®å½•ä¸­æœ‰ EDA.json æ–‡ä»¶ï¼‰')
    parser.add_argument('--dmin', type=float, default=1.5,
                       help='æœ€å°æ‰«æè·ç¦» (Ã…) [ä»…ç”¨äºè‡ªåŠ¨ç”Ÿæˆæ„å‹]')
    parser.add_argument('--dmax', type=float, default=8.0,
                       help='æœ€å¤§æ‰«æè·ç¦» (Ã…) [ä»…ç”¨äºè‡ªåŠ¨ç”Ÿæˆæ„å‹]')
    parser.add_argument('--npoints', type=int, default=25,
                       help='æ‰«æç‚¹æ•° [ä»…ç”¨äºè‡ªåŠ¨ç”Ÿæˆæ„å‹]')
    parser.add_argument('--direction', type=str, default='x',
                       choices=['x', 'y', 'z'],
                       help='æ‰«ææ–¹å‘ [ä»…ç”¨äºè‡ªåŠ¨ç”Ÿæˆæ„å‹]')
    parser.add_argument('--platform', type=str, default='CPU',
                       choices=['CPU', 'CUDA'],
                       help='OpenMM è®¡ç®—å¹³å°')
    parser.add_argument('--work_dir', type=str, default=None,
                       help='å·¥ä½œç›®å½•ï¼ˆé»˜è®¤ä¸º ./dimer_{mol1}_{mol2}ï¼‰')
    
    args = parser.parse_args()
    
    # è®¾ç½®å·¥ä½œç›®å½•
    if args.work_dir is None:
        args.work_dir = f'./dimer_{args.mol1}_{args.mol2}'
    
    print("="*60)
    print(f"ğŸ”¬ äºŒèšä½“èƒ½é‡è®¡ç®—: {args.mol1}Â·Â·Â·{args.mol2}")
    print("="*60)
    
    # åˆ›å»ºæ‰«æå™¨
    scanner = DimerEnergyScannerFromParams(
        params_dir=args.params_dir,
        work_dir=args.work_dir
    )
    
    # åˆ¤æ–­æ˜¯ä»ç»“æ„ç›®å½•è¿˜æ˜¯è‡ªåŠ¨ç”Ÿæˆæ„å‹
    if args.structure_dir:
        # ä»ç»“æ„ç›®å½•è®¡ç®—ï¼ˆæ”¯æŒå¤šæ„è±¡ï¼‰
        print(f"æ¨¡å¼: ä»ç»“æ„ç›®å½•è¯»å–å¤šæ„è±¡ ({args.structure_dir})")
        results = scanner.calculate_from_structure_dir(
            mol1_name=args.mol1,
            mol2_name=args.mol2,
            structure_dir=args.structure_dir,
            platform=args.platform,
            compare_qm=args.compare_qm
        )
        plot_qm = args.compare_qm
    else:
        # è‡ªåŠ¨ç”Ÿæˆæ‰«ææ„å‹
        print(f"æ¨¡å¼: è‡ªåŠ¨ç”Ÿæˆæ‰«ææ„å‹")
        distances = np.linspace(args.dmin, args.dmax, args.npoints)
        results = scanner.calculate_dimer_scan(
            mol1_name=args.mol1,
            mol2_name=args.mol2,
            distances=distances,
            scan_direction=args.direction,
            platform=args.platform
        )
        plot_qm = False
    
    # åˆ†æç»“æœ
    analysis = scanner.analyze_interaction_energy(results)
    
    # ç»˜åˆ¶èƒ½é‡åˆ†è§£å›¾
    scanner.plot_energy_decomposition(results, plot_qm=plot_qm)
    
    print("\n" + "="*60)
    print("âœ… è®¡ç®—å®Œæˆï¼")
    print(f"ğŸ“ æ‰€æœ‰ç»“æœå·²ä¿å­˜åˆ°: {args.work_dir}")
    print("="*60)


if __name__ == '__main__':
    main()
